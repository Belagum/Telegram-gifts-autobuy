# GiftBuyer

Веб-панель и бот для **мониторинга и автопокупки Telegram-подарков** на базе **Flask + SQLAlchemy + Pyrogram** (backend) и **React + Vite** (frontend).
Поддерживается работа с несколькими аккаунтами, просмотр баланса звёзд, список доступных подарков с предпросмотром **.tgs (Lottie)**, хранилище каналов с фильтрами (по цене и supply), отправка уведомлений в каналы/ЛС и **автопокупка лимитных подарков на нужные каналы**.

---

## Ключевые возможности

*  Регистрация/логин (httpOnly cookie, 7 дней).
*  Несколько **API-профилей** (api\_id/api\_hash) и **несколько Telegram-аккаунтов** на пользователя.
*  Просмотр Premium, **баланс звёзд**, принудительное обновление данных аккаунтов со стримом стадий (NDJSON).
*  **Подарки (Gifts)**: список, ручное/фоновое обновление, SSE-стрим, предпросмотр .tgs (серверный кэш).
*  **Каналы**: добавление по `channel_id` (формат `-100…`), проверка членства, хранение названия и фильтров **цена/supply**, CRUD.
*  **Автопокупка** лимитных подарков на каналы по заданным фильтрам, с отчётами в ЛС и подробными причинами, если не купилось.
*  **Уведомления** о новых подарках в указанные каналы/ЛС (со стикером и кратким текстом).
*  Бэкграунд-воркер подарков, устойчивый к падениям и переподключениям, с «горячим» перечитыванием аккаунтов.
---

## Как работает автопокупка (кратко про алгоритм)

Файл: `backend/services/autobuy_service.py`

1. **Сбор входных данных**

   * Берём **все аккаунты** пользователя и узнаём их **баланс звёзд**.
   * Берём **все каналы** пользователя и их фильтры:

     * диапазон `price_min..price_max`;
     * диапазон `supply_min..supply_max` (если `null` — без ограничения).
   * Берём **новые подарки**, пришедшие от воркера.
     ⚠ В боевом режиме покупаем **только лимитные** (`is_limited=True`). Нелимитные сразу скипаем с причиной.

2. **Фильтрация и приоритезация подарков**

   * Отсекаем мусор (некорректные `id/price/supply`).
   * Сортируем лимитки по ключу: **меньше supply → дороже → случайность(если одинаковая цена и supply)**.

3. **Планирование («план покупок»)**
   Для **каждого аккаунта** (в порядке убывания баланса) распределяем покупки:

   * Для конкретного подарка ищется **подходящий канал** (по фильтрам цены/supply).
   * Рассчитывается максимально возможное количество отправок с учётом **остатка баланса** аккаунта и **доступности** подарка.
   * В план добавляются операции: `(account_id, channel_id, gift_id, price, supply)`.
   * Если на этапе планирования что-то не сошлось (нет подходящих каналов, не хватило звёзд и т.п.), это фиксируется в `plan_skips`.

4. **Исполнение плана**

   * Идём по плану и на каждой операции вызываем:

     ```
     await tg_client.send_gift(chat_id=<ID канала>, gift_id=<ID подарка>)
     ```
   * Успех/неуспех детально логируются в статистике **по каналам** и **по аккаунтам**.

5. **Отчёты**

   * Формируется отчёт: общая сводка, по подаркам, по каналам и по аккаунтам.
   * Отчёт уходит в **лс всех ваших аккаунтов** (через ваш Bot Token из «Настроек»).

6. **Параллельно** воркер шлёт **уведомления** о новых подарках в каналы/ЛС.
   В `gifts_service` покупка и уведомления запускаются одновременно (`asyncio.gather`), покупка **не блокирует** уведомления.


## Требования

* **Python** 3.13+
* **Node** 18+ / npm 9+
* Рабочий **api\_id/api\_hash** (my.telegram.org → API development tools)
* Ваш **Bot Token** (BotFather), чтобы слать .tgs-превью и отчёты в ЛС
* Чаты, куда бот имеет право писать (если хотите уведомления в каналы)

---

## Установка и запуск (локально)

### Backend

```bash
cd backend
python -m venv .venv
# Windows:
.\.venv\Scripts\activate
# macOS/Linux:
# source .venv/bin/activate

pip install -r requirements.txt

# (опционально) миграция/инициализация БД,
# если у вас есть перенос схемы:
python -m backend.migrate_app_db

# либо через новый скрипт (создаёт резервную копию):
python -m backend.scripts.migrate_data app.db --migration 0001_initial.sql

# запуск dev-сервера (Flask)
python -m backend.app     # http://localhost:5000
```

**Переменные окружения (необязательно):**

* `SECRET_KEY` — секрет Flask.
* `DATABASE_URL` — строка подключения SQLAlchemy (по умолчанию `sqlite:///app.db`).
* `DATABASE_POOL_SIZE` / `DATABASE_MAX_OVERFLOW` / `DATABASE_POOL_TIMEOUT` — настройки пула подключений.
* `GIFTS_DIR` — каталог с данными подарков (по умолчанию `gifts_data`).
* `GIFTS_CACHE_DIR` — кэш .tgs (по умолчанию `backend/instance/gifts_cache`).
* `GIFTS_ACCS_TTL` — период (сек) переобновления списка аккаунтов воркером (по умолчанию `60`).
* `METRICS_ENABLED` — включить экспорт Prometheus-метрик (по умолчанию `True`).
* `RESILIENCE_TIMEOUT`, `RESILIENCE_RETRIES`, `RESILIENCE_BACKOFF_BASE`, `RESILIENCE_BACKOFF_CAP` — таймауты и параметры повторов.

### Frontend

```bash
cd frontend
npm i
npm run dev     # http://localhost:5173
```

При необходимости настройте прокси `/api` → `http://localhost:5000` во `vite.config.js`.

### Здоровье и наблюдаемость

* `/healthz` — базовая проверка живости процесса.
* `/readyz` — проверяет подключение к БД.
* `/metrics` — Prometheus-метрики (`giftbuyer_request_latency_seconds`, `giftbuyer_requests_total`, `giftbuyer_workers`).

### Миграции и безопасный перенос данных

* Первичное создание схемы выполняет `python -m backend.migrate_app_db` или `python -m backend.scripts.migrate_data app.db --migration 0001_initial.sql`.
* `backend/scripts/migrate_data.py` перед применением SQL-файла создаёт резервную копию `<имя>.bak` рядом с БД.
* Для отката достаточно остановить приложение, заменить рабочий файл БД на `.bak` и повторить миграцию после фикса ошибки.
* Миграции атомарны (`BEGIN/COMMIT`), индексы (`idx_channels_user_id`, `idx_channels_channel_id`) ускоряют выборки фильтров.

### Метрики, трейсинг и примеры дашбордов

* Метрики Prometheus включаются переменной `METRICS_ENABLED`. Базовый набор:
  * `giftbuyer_request_latency_seconds` (Histogram) — латентность HTTP. Пример запроса: `histogram_quantile(0.95, sum(rate(giftbuyer_request_latency_seconds_bucket[5m])) by (le))`.
  * `giftbuyer_requests_total{endpoint="api.gifts"}` — частота обращений к конечным точкам.
  * `giftbuyer_workers` — текущее число фоновых воркеров.
* Рекомендуемый Grafana-дэшборд:
  * Панель «P95 HTTP latency» с формулой выше и единицами «milliseconds».
  * Панель «Request rate by endpoint» c `sum(rate(giftbuyer_requests_total[1m])) by (endpoint)`.
  * Панель «Active workers» c `giftbuyer_workers` (stat / gauge).
* Трейсинг можно подключить через OpenTelemetry, установив `TRACING_ENABLED=1` и интегрировав собственный OTLP экспортёр (точка расширения — `backend/infrastructure/observability.py`).

### Конфигурация и секреты

* Все параметры читаются из переменных окружения и валидируются Pydantic-моделью (`backend/config.py`).
* Секреты (токены, ключи) рекомендуется передавать через секрет-менеджер (Docker Secrets, Vault) и экспортировать в окружение процесса.
* При запуске директории `GIFTS_DIR` и `GIFTS_CACHE_DIR` создаются автоматически.

### Точки отказа и устойчивость

* Внешние запросы Telegram обёрнуты в `resilient_call` с таймаутом, экспоненциальным бэкоффом и circuit breaker (см. `backend/infrastructure/resilience.py`). При достижении порога отказов запросы блокируются до истечения `RESILIENCE_CIRCUIT_RESET`.
* Очередь уведомлений использует `ResilientQueue` с visibility timeout, позволяющим повторно ставить сообщения при сбоях воркера (`backend/infrastructure/queue.py`).
* Доступ к БД через UoW (`backend/infrastructure/unit_of_work.py`) гарантирует rollback при исключениях.
* Health/ready-пробы автоматически отлавливают недоступность БД и позволяют оркестратору перезапустить контейнер.

### Производительность и нагрузочные проверки

* Синтетический тест автопокупки (100 аккаунтов, 200 подарков) выполняется скриптом: `python -m backend.tests.synth_bench_autobuy` (см. примеры в разделе тестов).
* На эталонной машине (2 vCPU, 4 ГБ RAM) полный цикл планирования + отправки отчёта занял ~0.84 с, при этом средняя скорость обработки составила ~238 операций/с (см. раздел «Testing» ниже).


## Автопокупка — правила и приоритеты

* Покупаем **только лимитные** подарки (`is_limited=True`). Нелимитные фиксируются как «пропущены» с причиной.
* Для каждого подарка подбирается **лучший канал** среди подходящих по фильтрам `price` и `supply`:

  * Если `supply_min/max` у канала `null` — без ограничения.
  * Чем **уже** «окно» по supply и чем **выше** `price_max`, тем **выше приоритет** канала.
* План распределяется **по всем аккаунтам** (сортируются по убыванию баланса):

  * На каждый аккаунт ставится столько покупок, сколько позволяет **баланс** и **доступность** подарка.
* Отправка происходит именно **в канал**: `send_gift(chat_id=<ID канала>, gift_id=...)`.
* Подробные причины, почему не купили:

  * `no_channel_match` — не нашлось каналов, где и `price`, и `supply` укладываются в фильтры.
  * `not_enough_stars` / `insufficient_account_balance` — не хватило звёзд.
  * `send_gift_failed` — сам вызов `send_gift` провалился (нет прав писать в канал, не член канала, gift больше недоступен, требуются Premium, и т.п.).
  * `invalid/price/supply` — подарок не прошёл базовую валидацию.
* В ЛС уходит **отчёт** с эмодзи: сводка, по подаркам (что и куда купили, либо почему пропущено), по каналам и по аккаунтам.


## Настройки и важные поля

* **User.gifts\_autorefresh** — вкл/выкл автопокупку.
* **UserSettings.bot\_token** — используется для отправки .tgs-стикеров и текстов в каналы/ЛС (уведомления и отчёты).
* **Channel**:

  * `channel_id` вида `-100…` (обязательно).
  * `price_min` / `price_max` — в звёздах.
  * `supply_min` / `supply_max` — общее издание (если `null`, ограничения нет).
* **Account**:

  * привязан к API-профилю;
  * в UI виден баланс звёзд; баланс запрашивается при планировании.

---

## Отчёты и логи

* В **консоли**: подробно логируется план/исполнение, причины ошибок по каналам/аккаунтам, глобальные пропуски.
* В **ЛС (всем вашим аккаунтам)**:

```
🧾 Отчёт автопокупки
📊 Новых: 3 | Куплено: 2 | Пропущено: 1

📦 По подаркам:
• ✅ 123456 | 25⭐ | supply=1000 → ch=-100111 acc=1337
• ⏭️ 654321 | 50⭐ | supply=∞ → non-limited (skipped)
• ❌ 222333 | 10⭐ | supply=500 → причина ch=-100222: insufficient_account_balance acc=1338 bal=5 need=10

🛰️ По каналам:
• -100111: plan=1 ok=1 fail=0 reasons=0
• -100222: plan=1 ok=0 fail=0 reasons=1

👤 По аккаунтам:
• acc=1337: plan=1 💰spent=25 start=100 end=75 buys=1
• acc=1338: plan=1 💰spent=0 start=5 end=5 buys=0
```

---

## Частые проблемы и решения

* **`send_gift_failed`**
  Проверьте:

  * аккаунт **состоит** в канале;
  * у бота есть право писать (для уведомлений), и **аккаунт** имеет право отправлять gift;
  * gift уже не закончился/не изменился;
  * gift **не требует Premium**, если у аккаунта его нет;
  * баланс достаточен.

* **Нет покупок, «no\_channel\_match»**
  Подарок не попал в рамки ни одного канала. Проверьте `price_min/max` и `supply_min/max`.

* **Ничего не видно в «Подарках»**
  Нажмите ручное обновление или дождитесь воркера. Проверьте токен бота (для предпросмотра .tgs).

* **Windows продакшен**
  Gunicorn недоступен. Используйте `waitress-serve` или разворачивайте на Linux-сервере.


## Лицензия

Apache-2.0 © 2025 Vova Orig. См. LICENSE и NOTICE.

---
